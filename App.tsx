import React, { useState, useEffect } from 'react';
import { WorkoutPlanner } from './components/WorkoutPlanner';
import { PlanDashboard } from './components/PlanDashboard';
import { ActiveWorkout } from './components/ActiveWorkout';
import { BodyAnalysisModal } from './components/BodyAnalysisModal';
import { InitialAnalysisPromptModal } from './components/InitialAnalysisPromptModal';
import { WorkoutPlan, WorkoutSession, DayWorkout, Exercise, BodyAnalysis, Preferences, ActiveSessionData } from './types';
import { useStickyState } from './hooks/useStickyState';
import { useOnlineStatus } from './hooks/useOnlineStatus';
import { Documentation } from './components/Documentation';
import { FAQ } from './components/FAQ';
import { AppFooter } from './components/AppFooter';
import { generateWorkoutPlan, checkProgressForScheduleChange } from './services/geminiService';
import { AutoGenerationLoader } from './components/AutoGenerationLoader';
import { ScheduleSuggestionModal } from './components/ScheduleSuggestionModal';
import { OfflineWarning } from './components/OfflineWarning';
import { ConfirmationModal } from './components/ConfirmationModal';
import { layout } from './styles/theme';

/**
 * A helper function to get a unique week identifier string (e.g., "2024-23") from a date.
 * This is used to automatically reset the weekly plan completion status.
 * It uses the ISO 8601 week numbering system for consistency.
 * @param d The date to get the week number for.
 * @returns A string in "YYYY-WW" format.
 */
const getWeekNumber = (d: Date): string => {
  d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
  const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
  const weekNo = Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);
  return `${d.getUTCFullYear()}-${String(weekNo).padStart(2, '0')}`;
};

/**
 * The main application component. It orchestrates state management and renders the
 * appropriate view based on the application's current state (e.g., planner, dashboard, active workout).
 */
function App() {
  // --- STATE MANAGEMENT ---
  // The useStickyState hook persists these values to localStorage, providing seamless session continuity.

  /** The current workout plan generated by the AI. Null if no plan exists. */
  const [workoutPlan, setWorkoutPlan] = useStickyState<WorkoutPlan | null>(null, 'kinetix-workout-plan');
  /** A complete history of all completed workout sessions. */
  const [workoutHistory, setWorkoutHistory] = useStickyState<WorkoutSession[]>([], 'kinetix-workout-history');
  /** A history of all AI body composition analysis results. */
  const [analysisHistory, setAnalysisHistory] = useStickyState<BodyAnalysis[]>([], 'kinetix-analysis-history');
  /** Tracks the user's current workout streak. */
  const [streak, setStreak] = useStickyState({ current: 0, lastWorkoutDate: '' }, 'kinetix-workout-streak');
  /** Stores the user's preferences from the workout planner to be used for future plan generations. */
  const [preferences, setPreferences] = useStickyState<Preferences | null>(null, 'kinetix-preferences');
  /** An array of 'day' strings that have been completed in the current weekly plan. */
  const [completedDays, setCompletedDays] = useStickyState<string[]>([], 'kinetix-completed-days');
  /** The unique week identifier for the current plan, used to reset progress weekly. */
  const [planWeek, setPlanWeek] = useStickyState<string>(getWeekNumber(new Date()), 'kinetix-plan-week');
  /** A flag that unlocks the body analysis feature after the first plan is fully completed. */
  const [hasCompletedFirstPhase, setHasCompletedFirstPhase] = useStickyState<boolean>(false, 'kinetix-has-completed-phase');
  /** A flag to indicate that a new plan should be generated as soon as the user comes back online. */
  const [planGenerationQueued, setPlanGenerationQueued] = useStickyState<boolean>(false, 'kinetix-plan-queued');
  /** A flag to ensure the initial "before" analysis prompt is only ever shown once. */
  const [hasSeenInitialPrompt, setHasSeenInitialPrompt] = useStickyState<boolean>(false, 'kinetix-has-seen-initial-prompt');
  /** The current theme ('light' or 'dark'). */
  const [theme, setTheme] = useStickyState<'light' | 'dark'>('dark', 'kinetix-theme');
  
  // --- LOCAL UI STATE & PERSISTED ACTIVE WORKOUT STATE ---
  /** Holds the workout object for the currently active session. Null if no workout is active. */
  const [activeWorkout, setActiveWorkout] = useStickyState<DayWorkout | null>(null, 'kinetix-active-workout');
  /** The index of the current exercise in the active workout. */
  const [activeExerciseIndex, setActiveExerciseIndex] = useStickyState<number>(0, 'kinetix-active-exercise-index');
  /** Holds the performance data for the in-progress workout session. */
  const [activeSessionData, setActiveSessionData] = useStickyState<ActiveSessionData | null>(null, 'kinetix-active-session-data');
  /** The timestamp when the current workout was started, used for duration tracking. */
  const [workoutStartTime, setWorkoutStartTime] = useStickyState<number | null>(null, 'kinetix-workout-start-time');

  const [viewingDocs, setViewingDocs] = useState(false);
  const [viewingFAQ, setViewingFAQ] = useState(false);
  const [isAutoGenerating, setIsAutoGenerating] = useState(false);
  const [showScheduleSuggestion, setShowScheduleSuggestion] = useState(false);
  const [showInitialAnalysisPrompt, setShowInitialAnalysisPrompt] = useState(false);
  const [isAnalysisModalOpen, setIsAnalysisModalOpen] = useState(false);
  const [isClearDataModalOpen, setIsClearDataModalOpen] = useState(false);

  const isOnline = useOnlineStatus();

  // --- EFFECTS ---
  
  // Effect to apply the theme class to the root HTML element.
  useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove('light', 'dark');
    root.classList.add(theme);
  }, [theme]);

  // Effect to check for and execute a queued plan generation when the user comes back online.
  useEffect(() => {
    if (isOnline && planGenerationQueued) {
      console.log("Back online, attempting to generate queued plan...");
      orchestrateNextPlanGeneration();
      setPlanGenerationQueued(false); // Attempt generation, then clear the queue flag.
    }
  }, [isOnline, planGenerationQueued]);
  
  // Effect to reset the weekly completion status at the start of a new calendar week.
  useEffect(() => {
    const currentWeek = getWeekNumber(new Date());
    if (planWeek !== currentWeek) {
        setCompletedDays([]);
        setPlanWeek(currentWeek);
    }
  }, [planWeek, setCompletedDays, setPlanWeek]);

  // --- HANDLERS ---
  const handleToggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'dark' ? 'light' : 'dark'));
  };

  /** Handles the creation of a new workout plan. */
  const handlePlanGenerated = (plan: WorkoutPlan, prefs?: Preferences) => {
    if (!hasSeenInitialPrompt) {
      setShowInitialAnalysisPrompt(true);
      setHasSeenInitialPrompt(true);
    }
    setWorkoutPlan(plan);
    if (prefs) {
      setPreferences(prefs);
    }
    setCompletedDays([]); // Reset completion status for the new plan.
    setPlanWeek(getWeekNumber(new Date()));
  };
  
  /** Handles importing all application data from a JSON file. */
  const handleImportData = (data: { plan: WorkoutPlan; workoutHistory: any[]; streak: any; preferences?: Partial<Preferences>; completedDays?: string[], analysisHistory?: BodyAnalysis[], hasCompletedFirstPhase?: boolean }) => {
    setWorkoutPlan(data.plan);
    setWorkoutHistory(data.workoutHistory);
    setStreak(data.streak || { current: 0, lastWorkoutDate: '' });
    
    if (data.preferences) {
        const completePreferences: Preferences = {
            height: '',
            weight: '',
            injuries: '',
            fitnessLevel: 'Beginner',
            daysPerWeek: '3',
            duration: '',
            equipment: ['Bodyweight'],
            desiredGoals: [],
            excludedGoals: [],
            specificDays: [],
            ...data.preferences,
        };
        setPreferences(completePreferences);
    } else {
        setPreferences(null);
    }

    setCompletedDays(data.completedDays || []);
    setAnalysisHistory(data.analysisHistory || []);
    setHasCompletedFirstPhase(data.hasCompletedFirstPhase || false);
    setHasSeenInitialPrompt(true); // Assume imported data means they are past the initial prompt phase.
  };
  
  /** Initializes and persists the state for a new workout session. */
  const handleStartWorkout = (workout: DayWorkout) => {
    setActiveWorkout(workout);
    setActiveExerciseIndex(0);
    // Initialize the data structure for logging sets and reps.
    setActiveSessionData(
      workout.exercises.map(ex => ({
        exerciseName: ex.name,
        sets: Array.from({ length: parseInt(ex.sets, 10) }, () => ({ reps: '', weight: '' })),
        effort: undefined,
      }))
    );
    setWorkoutStartTime(Date.now());
  };
  
  /** Updates the user's workout streak based on the date of the completed session. */
  const updateStreak = (sessionDate: string) => {
    const today = new Date(sessionDate).toDateString();
    const lastWorkout = streak.lastWorkoutDate ? new Date(streak.lastWorkoutDate) : null;
    
    if (!lastWorkout) {
        setStreak({ current: 1, lastWorkoutDate: sessionDate });
        return;
    }
    
    // Do not increase streak if another workout was completed on the same day.
    if (today === lastWorkout.toDateString()) return;

    const yesterday = new Date(lastWorkout);
    yesterday.setDate(yesterday.getDate() + 1);

    if (today === yesterday.toDateString()) {
      // Consecutive days, increment streak.
      setStreak(prev => ({ current: prev.current + 1, lastWorkoutDate: sessionDate }));
    } else {
      // Streak broken, reset to 1.
      setStreak({ current: 1, lastWorkoutDate: sessionDate });
    }
  };

  /**
   * A reusable function to generate and set a new workout plan.
   * If offline, it queues the generation.
   * @param prefsToUse The preferences to use for generation (defaults to stored preferences).
   */
  const generateAndSetNewPlan = async (prefsToUse: Preferences | null = preferences) => {
      if (!isOnline) {
        setPlanGenerationQueued(true);
        return;
      }
      if (!prefsToUse) {
        console.error("Cannot generate next plan without preferences.");
        setWorkoutPlan(null); // Fallback to planner.
        return;
      }
      
      try {
        const plan = await generateWorkoutPlan(prefsToUse, workoutHistory);
        handlePlanGenerated(plan, prefsToUse);
      } catch (error) {
        console.error("Failed to auto-generate next plan:", error);
        setWorkoutPlan(null); // Fallback to planner on error.
      }
  };

  /**
   * The main logic for automatic progression. It checks for potential schedule changes
   * before generating the next plan.
   */
  const orchestrateNextPlanGeneration = async () => {
      if (!isOnline) {
        setPlanGenerationQueued(true);
        return;
      }
      if (!preferences || !workoutPlan) {
          await generateAndSetNewPlan();
          return;
      }
      
      setIsAutoGenerating(true);
      // Analyze only the workouts from the just-completed phase.
      const lastPhaseHistory = workoutHistory.slice(-workoutPlan.length);
      const suggestion = await checkProgressForScheduleChange(preferences, lastPhaseHistory);
      
      if (suggestion === 'add_day') {
          // If AI suggests adding a day, show the modal to the user first.
          setIsAutoGenerating(false);
          setShowScheduleSuggestion(true);
      } else {
          // Otherwise, proceed with generating the next plan.
          await generateAndSetNewPlan();
          setIsAutoGenerating(false);
      }
  };
  
  /** Clears all state related to an active workout session. */
  const clearActiveWorkoutState = () => {
    setActiveWorkout(null);
    setActiveExerciseIndex(0);
    setActiveSessionData(null);
    setWorkoutStartTime(null);
  };

  /**
   * Main callback for when a workout session is finished.
   * It updates history, streak, and completion status, then triggers the next plan generation if needed.
   */
  const handleWorkoutComplete = async (session: Omit<WorkoutSession, 'duration'>) => {
    const endTime = Date.now();
    const duration = workoutStartTime ? Math.round((endTime - workoutStartTime) / 1000) : undefined;
    const completeSession: WorkoutSession = { ...session, duration };

    const updatedHistory = [...workoutHistory, completeSession];
    setWorkoutHistory(updatedHistory);
    updateStreak(session.date);
    clearActiveWorkoutState();

    const updatedCompletedDays = Array.from(new Set([...completedDays, session.day]));
    setCompletedDays(updatedCompletedDays);

    // Check if all workouts for the week are now complete.
    if (workoutPlan && updatedCompletedDays.length >= workoutPlan.length) {
      if (!hasCompletedFirstPhase) {
        setHasCompletedFirstPhase(true); // Unlock features after the first phase.
      }
      // Trigger the automatic generation of the next phase.
      await orchestrateNextPlanGeneration();
    }
  };

  /** Handles the user declining the AI's suggestion to add a workout day. */
  const handleDeclineScheduleSuggestion = async () => {
    setShowScheduleSuggestion(false);
    setIsAutoGenerating(true);
    await generateAndSetNewPlan(); // Generate plan with original preferences.
    setIsAutoGenerating(false);
  };

  /** Handles the user accepting the AI's suggestion to add a workout day. */
  const handleAcceptScheduleSuggestion = async () => {
    if (!preferences) return;
    setShowScheduleSuggestion(false);
    const currentDays = parseInt(preferences.daysPerWeek, 10);
    // Create new preferences with one additional day.
    const newPrefs: Preferences = {
        ...preferences,
        daysPerWeek: String(currentDays + 1),
        specificDays: [],
        desiredGoals: Array(currentDays + 1).fill(''),
    };
    setPreferences(newPrefs);

    setIsAutoGenerating(true);
    await generateAndSetNewPlan(newPrefs); // Generate plan with the new preferences.
    setIsAutoGenerating(false);
  };

  const handleCancelWorkout = () => {
    clearActiveWorkoutState();
  };

  /** Resets the app to the initial planner state, keeping history. */
  const handleResetPlan = () => {
    setWorkoutPlan(null);
    setPreferences(null);
    setCompletedDays([]);
  };
  
  /** Clears all application data from local storage and reloads the page. */
  const handleClearAllData = () => {
    // Define the full list of keys used for persistent storage.
    const keysToClear = [
      'kinetix-workout-plan',
      'kinetix-workout-history',
      'kinetix-analysis-history',
      'kinetix-workout-streak',
      'kinetix-preferences',
      'kinetix-completed-days',
      'kinetix-plan-week',
      'kinetix-has-completed-phase',
      'kinetix-plan-queued',
      'kinetix-has-seen-initial-prompt',
      'kinetix-theme',
      'kinetix-info-seen',
      'kinetix-active-workout',
      'kinetix-active-exercise-index',
      'kinetix-active-session-data',
      'kinetix-workout-start-time',
    ];

    // Clear all items from localStorage.
    keysToClear.forEach(key => {
        try {
            window.localStorage.removeItem(key);
        } catch (error) {
            console.error(`Failed to remove item ${key} from localStorage:`, error);
        }
    });

    // To ensure a clean slate and prevent any race conditions with sticky state hooks,
    // we also reset the in-memory React state to its default values before reloading.
    setWorkoutPlan(null);
    setWorkoutHistory([]);
    setAnalysisHistory([]);
    setStreak({ current: 0, lastWorkoutDate: '' });
    setPreferences(null);
    setCompletedDays([]);
    setPlanWeek(getWeekNumber(new Date()));
    setHasCompletedFirstPhase(false);
    setPlanGenerationQueued(false);
    setHasSeenInitialPrompt(false);
    setTheme('dark'); // Reset to default theme
    clearActiveWorkoutState();

    // Finally, reload the page to ensure the application starts fresh from its initial state.
    window.location.reload();
  };

  /** Updates the master workout plan when an exercise is swapped during a session. */
  const handleUpdateExerciseInPlan = (day: string, originalExerciseName: string, newExercise: Exercise) => {
    setWorkoutPlan(currentPlan => {
        if (!currentPlan) return null;
        return currentPlan.map(workoutDay => {
            if (workoutDay.day === day) {
                return {
                    ...workoutDay,
                    exercises: workoutDay.exercises.map(ex => 
                        ex.name === originalExerciseName ? newExercise : ex
                    ),
                };
            }
            return workoutDay;
        });
    });
  };

  /** Saves the result of a body composition analysis to history. */
  const handleAnalysisComplete = (result: string) => {
    const newAnalysis: BodyAnalysis = {
      date: new Date().toISOString(),
      result: result,
    };
    setAnalysisHistory(prev => [...prev, newAnalysis]);
  };

  /** Handles the user choosing to perform the initial analysis from the prompt. */
  const handlePromptAnalyze = () => {
    setShowInitialAnalysisPrompt(false);
    setIsAnalysisModalOpen(true);
  };

  // --- RENDER LOGIC ---

  if (viewingDocs) {
    return <Documentation onClose={() => setViewingDocs(false)} />;
  }

  if (viewingFAQ) {
    return <FAQ onClose={() => setViewingFAQ(false)} />;
  }
  
  if (isAutoGenerating) {
    return <AutoGenerationLoader />;
  }

  if (activeWorkout && activeSessionData) {
    return <ActiveWorkout 
              workout={activeWorkout} 
              history={workoutHistory}
              preferences={preferences}
              exerciseIndex={activeExerciseIndex}
              sessionData={activeSessionData}
              setSessionData={setActiveSessionData}
              setExerciseIndex={setActiveExerciseIndex}
              onWorkoutComplete={handleWorkoutComplete} 
              onCancel={handleCancelWorkout} 
              onExerciseSwap={handleUpdateExerciseInPlan}
            />;
  }

  return (
    <div className={layout.pageContainer}>
      <OfflineWarning isOnline={isOnline} />
      <main className={layout.mainContent}>
        {workoutPlan ? (
          <PlanDashboard
            plan={workoutPlan}
            history={workoutHistory}
            analysisHistory={analysisHistory}
            streak={streak}
            preferences={preferences}
            completedDays={completedDays}
            hasCompletedFirstPhase={hasCompletedFirstPhase}
            hasSeenInitialPrompt={hasSeenInitialPrompt}
            isOnline={isOnline}
            planGenerationQueued={planGenerationQueued}
            onStartWorkout={handleStartWorkout}
            onResetPlan={handleResetPlan}
            onUpdateExercise={handleUpdateExerciseInPlan}
            onOpenAnalysisModal={() => setIsAnalysisModalOpen(true)}
          />
        ) : (
          <WorkoutPlanner onPlanGenerated={handlePlanGenerated} onImportData={handleImportData} history={workoutHistory} isOnline={isOnline} />
        )}
      </main>
      <AppFooter 
        onShowDocs={() => setViewingDocs(true)} 
        onShowFAQ={() => setViewingFAQ(true)}
        onClearData={() => setIsClearDataModalOpen(true)}
        theme={theme}
        onToggleTheme={handleToggleTheme}
      />
      <ScheduleSuggestionModal
        isOpen={showScheduleSuggestion}
        onAccept={handleAcceptScheduleSuggestion}
        onDecline={handleDeclineScheduleSuggestion}
        isOnline={isOnline}
      />
      <InitialAnalysisPromptModal
        isOpen={showInitialAnalysisPrompt}
        onClose={() => setShowInitialAnalysisPrompt(false)}
        onAnalyze={handlePromptAnalyze}
      />
      <BodyAnalysisModal
        isOpen={isAnalysisModalOpen}
        onClose={() => setIsAnalysisModalOpen(false)}
        onAnalysisComplete={handleAnalysisComplete}
      />
      <ConfirmationModal
        isOpen={isClearDataModalOpen}
        onClose={() => setIsClearDataModalOpen(false)}
        onConfirm={handleClearAllData}
        title="Clear All Data?"
        message="Are you sure you want to permanently delete all your data, including your workout plan, history, and preferences? This action cannot be undone."
      />
    </div>
  );
}

export default App;
